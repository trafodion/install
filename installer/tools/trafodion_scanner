#!/usr/bin/python -tt

# @@@ START COPYRIGHT @@@
#
# (C) Copyright 2014 Hewlett-Packard Development Company, L.P.
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
#
# @@@ END COPYRIGHT @@@

import os
import sys
import tempfile
import re
import logging
import subprocess
import string
from optparse import OptionParser

def configure_trafodion_scanner_logger():
  logger = logging.getLogger("trafodion_scanner_logger")
  logger.setLevel(logging.DEBUG)
  formatter = logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s")
  fh = logging.FileHandler('trafodion_scanner.log')
  fh.setLevel(logging.DEBUG)
  fh.setFormatter(formatter)
  logger.addHandler(fh)
  return logger
  
def compare_check_result(result,expected_result,comparison_operator):
  # for the comparison operators (str_lt, str_le, str_eq, str_ne, str_ge, str_gt),
  # we first cast the result and expected_result to string type, to enable correct comparison
  if (comparison_operator.startswith('str_')):
    result = str(result); expected_result = str(expected_result)  
  
  # for the comparison operators (int_lt, int_le, int_eq, int_ne, int_ge, int_gt),
  # we first cast the result and expected_result to integer type, to enable correct comparison  
  if (comparison_operator.startswith('int_')):
    result = int(result); expected_result = int(expected_result)

  if (comparison_operator.endswith('lt')):
    return expected_result < result
  if (comparison_operator.endswith('le')):
    return expected_result <= result
  if (comparison_operator.endswith('eq')):
    return expected_result == result
  if (comparison_operator.endswith('ne')):
    return expected_result != result
  if (comparison_operator.endswith('ge')):
    return expected_result >= result
  if (comparison_operator.endswith('gt')):
    return expected_result > result

def exec_command_with_exit_code(cmd_string):
  temp_file=tempfile.TemporaryFile()
  exit_code = subprocess.call(cmd_string, stdout=temp_file, stderr=subprocess.STDOUT, shell=True)
  temp_file.seek(0) # go back to start of file before read
  cmd_output = temp_file.read()
  cmd_output = cmd_output.strip() # trim leading and trailing whitespace before comparison
  return (cmd_output, exit_code)

def exec_command(cmd_string):
  (cmd_output, exit_code) = exec_command_with_exit_code(cmd_string)
  return cmd_output
  
def exec_command_remote(cmd_string,node_name):
  named_temp_file=tempfile.NamedTemporaryFile(delete=False)
  named_temp_file.write(cmd_string)
  named_temp_file.close()
  cmd_output = exec_command('cat ' + named_temp_file.name + ' | ssh -oStrictHostKeyChecking=no -oBatchMode=yes -q -T ' + node_name)
  os.remove(named_temp_file.name)
  return cmd_output
  
def read_config(filename):
  with open(filename) as config:
    lines=[ line.split(':::') for line in config if not re.search('^#',line) and not re.search('^\s*$',line) ]
    logger = logging.getLogger("trafodion_scanner_logger")
    logger.info("Reading configuration file %s", filename)
    return lines

def check_passwordless_ssh_and_sudo_access(list_of_node_names, count_of_nodes):
  logger = logging.getLogger("trafodion_scanner_logger")
  count_of_inaccessible_nodes = 0
  count_of_nodes_without_sudo_access = 0
  for node_name in list_of_node_names:
    (cmd_output, exit_code) = exec_command_with_exit_code('echo "sudo -n echo test >/dev/null" | ssh -oStrictHostKeyChecking=no -oBatchMode=yes -T ' + node_name)
    if exit_code == 255: # ssh exits with 255 if an ssh-related error occurred, otherwise with the exit status of the remote command
      count_of_inaccessible_nodes += 1
      err_str = '***ERROR: Unable to access %s via passwordless ssh: %s' % (node_name, cmd_output)
      logger.error(err_str); print(err_str)
    elif exit_code == 1: # sudo exits with 1 if there is a configuration/permission problem
      count_of_nodes_without_sudo_access += 1
      if 'must have a tty to run sudo' in cmd_output:
        err_str = '***ERROR: sudo access is not correctly configured for the user running this script on node %s: requiretty must be disabled for this user in /etc/sudoers.' % (node_name)
        logger.error(err_str); print(err_str)
      else:
        err_str = '***ERROR: sudo access is not enabled for the user running this script on node %s: this script must be run by a user with full sudo access.' % (node_name)
        logger.error(err_str); print(err_str)
  if count_of_inaccessible_nodes > 0:
    err_str = 'Fatal error: unable to access %d of %d specified nodes via passwordless ssh.' % (count_of_inaccessible_nodes, count_of_nodes)
    logger.error(err_str); print(err_str)
  if count_of_nodes_without_sudo_access > 0:
    err_str = 'Fatal error: sudo access is not enabled and/or correctly configured for the user running this script on %d of %d specified nodes.' % (count_of_nodes_without_sudo_access, count_of_nodes)
    logger.error(err_str); print(err_str)
  if count_of_inaccessible_nodes > 0 or count_of_nodes_without_sudo_access > 0:
    err_str = 'Exiting due to fatal error(s).'
    logger.error(err_str); print(err_str)
    sys.exit(1)  
    
def main(argv):
  parser = OptionParser()
  parser.add_option("-c", "--config_file", dest="config_file", help="Trafodion Scanner configuration filename. Default is trafodion_scanner.cfg.", default="trafodion_scanner.cfg")
  parser.add_option("-n", "--nodes", dest="nodes", help="Blank-separated list of nodes (enclosed in quotes) on which you plan to install Trafodion. The trafodion scanner will check these nodes. These must be DNS names on your cluster. IP addresses are not supported. Example: --nodes \"node1 node2 node3 node4\". This is a required option.")
  (options, args) = parser.parse_args()  
    
  if (options.nodes is None) or (len(options.nodes.strip()) == 0):
    print '***ERROR: The --nodes (-n) option is required. Exiting.'
    sys.exit(1)      
    
  logger = configure_trafodion_scanner_logger()
  logger.info('Started')  
  logger.info('Using the following options: --config_file="%s", --nodes="%s"', options.config_file, options.nodes)
  
  list_of_node_names = sorted(options.nodes.split())
  count_of_nodes = len(list_of_node_names)
  
  # before doing any checks, we first validate that we can access the specified nodes via passwordless ssh
  # and that the userid running this script has full sudo access (required for some of the scanner checks 
  # and also for the Trafodion installation)
  check_passwordless_ssh_and_sudo_access(list_of_node_names, count_of_nodes)
  
  count_of_configuration_dump_items = 0
  count_of_configuration_check_items = 0
  
  check_failures_per_node = {}
  for node_name in list_of_node_names:
    check_failures_per_node[node_name] = []
  
  scan_lines=read_config(options.config_file)
  
  for i in range(len(scan_lines)):
    configuration_item = scan_lines[i][0].strip() # trim leading and trailing whitespace
    
    if configuration_item == 'CONFIGURATION_DUMP':
      descripion = scan_lines[i][1].strip() # trim leading and trailing whitespace
      command_string = scan_lines[i][2].strip() # trim leading and trailing whitespace
      count_of_configuration_dump_items += 1
      
      for node_name in list_of_node_names:      
        command_output = exec_command_remote(command_string, node_name)                   
        logger.info('Configuration Gathered on node %s: %s, command executed is %s, result is:\n%s', node_name, descripion, command_string, command_output)
        print 'Configuration Gathered on node ' + node_name + ': ' + string.ljust(descripion, 59) + '(see log)'

    else: 
      descripion = scan_lines[i][1].strip() # trim leading and trailing whitespace
      expected_value = scan_lines[i][2].strip() # trim leading and trailing whitespace
      comparison_operator = scan_lines[i][3].strip() # trim leading and trailing whitespace
      command_string = scan_lines[i][4].strip() # trim leading and trailing whitespace
      count_of_configuration_check_items += 1
      
      # validate the comparison_operator
      if (comparison_operator not in ('str_lt', 'str_le', 'str_eq', 'str_ne', 'str_ge', 'str_gt') and
          comparison_operator not in ('int_lt', 'int_le', 'int_eq', 'int_ne', 'int_ge', 'int_gt')):
        err_str = 'Fatal error: invalid comparison operator "%s" specified for configuration item "%s". Exiting.' % (comparison_operator, configuration_item)
        logger.error(err_str); print(err_str)
        sys.exit(1)  
  
      for node_name in list_of_node_names:
        check_outcome = ''
        command_output = exec_command_remote(command_string, node_name)          
        if (compare_check_result(command_output,expected_value,comparison_operator)):
          check_outcome = "PASS"
        else:
          check_outcome = "FAIL"
          check_failures_per_node[node_name].append(configuration_item)
        logger.info('Configuration Checked on node %s: %s :%s (command executed is %s, result is %s)', node_name, descripion, check_outcome, command_string, command_output)
        print 'Configuration Checked on node ' + node_name + ': ' + string.ljust(descripion, 60) + ':' + check_outcome
          
  ### report summary stats ###
  
  check_failures_per_node_as_sorted_strings = {}
  for node_name in list_of_node_names:
    if len(check_failures_per_node[node_name]) == 0:
      check_failures_per_node_as_sorted_strings[node_name] = 'All checks PASSED'
    else:
      sorted_check_failure_list = sorted(check_failures_per_node[node_name])        
      check_failures_per_node_as_sorted_strings[node_name] = ' check FAILED, '.join(sorted_check_failure_list) + ' check FAILED'
      
  check_failures_node_grouping = {}
  for node_name in list_of_node_names:
    check_failures_sorted_string = check_failures_per_node_as_sorted_strings[node_name]
    if check_failures_sorted_string in check_failures_node_grouping:
      check_failures_node_grouping[check_failures_sorted_string].append(node_name)
    else:
      check_failures_node_grouping[check_failures_sorted_string] = [node_name]
  
  summary_string = ''
  summary_string += 'Completed Execution on ' + str(count_of_nodes) + ' nodes: ' + ', '.join(list_of_node_names) + '\n'
  summary_string += 'Total Configuration Items Gathered: ' + str(count_of_configuration_dump_items) + '\n'
  summary_string += 'Total Configuration Items Checked: ' + str(count_of_configuration_check_items) + '\n'
  for check_failures_sorted_string in sorted(check_failures_node_grouping, key=len):
    summary_string += '  ' + ', '.join(check_failures_node_grouping[check_failures_sorted_string]) + ' - ' + check_failures_sorted_string + '\n'
  
  logger.info('Summary:\n\n%s', summary_string)
  print '\n******* SUMMARY *******\n' + summary_string
  
  logger.info('Stopped')    

# Call the main() function to begin the program
if __name__ == '__main__':
  main(sys.argv[1:])
